diff --git a/src/app/api/auth/login-from-email/route.ts b/src/app/api/auth/login-from-email/route.ts
new file mode 100644
index 0000000..32b76cf
--- /dev/null
+++ b/src/app/api/auth/login-from-email/route.ts
@@ -0,0 +1,35 @@
+import { NextResponse } from 'next/server';
+import { getVerifiedUserByCid, updateLastEmailEntryInUsersTable } from '@/lib/users';
+import { updateLastEmailEntryByCid } from '@/lib/data-access';
+
+export async function POST(req: Request): Promise<Response> {
+  try {
+    const body = (await req.json()) as { eid?: string; cid?: string };
+    const cid = (body.cid || '').trim();
+
+    if (!cid) {
+      return NextResponse.json({ success: false, error: 'Missing cid' }, { status: 400 });
+    }
+
+    const verifiedUser = await getVerifiedUserByCid(cid);
+    if (!verifiedUser) {
+      return NextResponse.json(
+        { success: false, error: 'User not verified or not found' },
+        { status: 403 },
+      );
+    }
+
+    await Promise.all([
+      updateLastEmailEntryInUsersTable(cid),
+      updateLastEmailEntryByCid(cid),
+    ]);
+
+    return NextResponse.json(
+      { success: true, email: verifiedUser.email ?? '' },
+      { status: 200 },
+    );
+  } catch (error) {
+    const message = error instanceof Error ? error.message : 'Server error';
+    return NextResponse.json({ success: false, error: message }, { status: 500 });
+  }
+}
diff --git a/src/app/api/health/route.ts b/src/app/api/health/route.ts
index 5843f71..e921913 100644
--- a/src/app/api/health/route.ts
+++ b/src/app/api/health/route.ts
@@ -1,4 +1,5 @@
 import { NextResponse } from "next/server";
+import '@/lib/error-logger'; 
 
 export async function GET() {
     return NextResponse.json({ status: "OK" });
diff --git a/src/app/api/log-client-error/route.ts b/src/app/api/log-client-error/route.ts
new file mode 100644
index 0000000..4a8fbee
--- /dev/null
+++ b/src/app/api/log-client-error/route.ts
@@ -0,0 +1,42 @@
+import { NextResponse } from 'next/server';
+import { sendEmailToAdmin } from '@/lib/email-service';
+
+const flag = Symbol.for('cross-stitch.logClientErrorThrottle');
+const globals = globalThis as Record<string | symbol, unknown>;
+
+export async function POST(req: Request): Promise<Response> {
+  try {
+    const body = (await req.json()) as Record<string, unknown>;
+    const timestamp = new Date().toISOString();
+
+    const payload = {
+      timestamp,
+      message: typeof body.message === 'string' ? body.message : 'Unknown client error',
+      stack: typeof body.stack === 'string' ? body.stack : undefined,
+      digest: typeof body.digest === 'string' ? body.digest : undefined,
+      url: typeof body.url === 'string' ? body.url : undefined,
+      userAgent: typeof body.userAgent === 'string' ? body.userAgent : undefined,
+    };
+
+    // Log server-side for visibility
+    console.error('Client error reported:', JSON.stringify(payload, null, 2));
+
+    // Throttle admin emails (minimum interval 60s)
+    const now = Date.now();
+    const lastSent = (globals[flag] as number | undefined) ?? 0;
+    if (now - lastSent >= 60_000) {
+      globals[flag] = now;
+      const pretty = JSON.stringify(payload, null, 2);
+      try {
+        await sendEmailToAdmin('[Client Error] App error reported', `<pre>${pretty}</pre>`, true);
+      } catch (err) {
+        console.error('Failed to email admin about client error:', err);
+      }
+    }
+
+    return NextResponse.json({ ok: true });
+  } catch (error) {
+    const message = error instanceof Error ? error.message : 'Server error';
+    return NextResponse.json({ ok: false, error: message }, { status: 500 });
+  }
+}
diff --git a/src/app/api/register-only/route.ts b/src/app/api/register-only/route.ts
index 05b0d04..19d91a1 100644
--- a/src/app/api/register-only/route.ts
+++ b/src/app/api/register-only/route.ts
@@ -5,8 +5,9 @@ import {
   EmailExistsError,
   type NewUserRegistration,
 } from '@/lib/users';
-import { sendEmailToAdmin } from '@/lib/email-service';
-import type { RegistrationSourceInfo } from '@/types/registration';
+import { sendEmail } from '@/lib/email-service';
+import { randomUUID } from 'crypto';
+import type { RegistrationSourceInfo } from '@/app/types/registration';
 
 type RegisterRequest = NewUserRegistration & {
   sourceInfo?: RegistrationSourceInfo | null;
@@ -25,40 +26,45 @@ export async function POST(req: Request): Promise<Response> {
 
     const sourceInfo = body.sourceInfo;
 
-    const result = await saveUserToDynamoDB({
+    const verificationToken = randomUUID();
+    const verificationTokenExpiresAt = new Date(Date.now() + 1000 * 60 * 60 * 48).toISOString(); // 48h
+    const redirectTarget = sourceInfo?.designUrl;
+
+    await saveUserToDynamoDB({
       email: body.email,
       firstName: body.firstName,
       password: body.password,
+      verificationToken,
+      verificationTokenExpiresAt,
     });
 
-    try {
-      const sourceRows = sourceInfo
-        ? [
-            `<li><strong>Source:</strong> ${sourceInfo.label ?? sourceInfo.source}</li>`,
-            sourceInfo.designUrl
-              ? `<li><strong>Design:</strong> <a href="${sourceInfo.designUrl}">${
-                  sourceInfo.designCaption ?? sourceInfo.designUrl
-                }</a></li>`
-              : '',
-          ].join('')
-        : '';
+    const host = req.headers.get('host') || 'cross-stitch-pattern.net';
+    const protocol =
+      host.includes('localhost') || host.startsWith('127.')
+        ? 'http'
+        : req.headers.get('x-forwarded-proto') || 'https';
+    const baseUrl = `${protocol}://${host}`;
+    const verificationLink = `${baseUrl}/api/register-only/verify?token=${verificationToken}${
+      redirectTarget ? `&redirect=${encodeURIComponent(redirectTarget)}` : ''
+    }`;
 
-      await sendEmailToAdmin(
-        `New user registered: ${body.firstName}`,
-        `<p>A new user has registered on Cross Stitch Pattern.</p>
-        <ul>
-          <li><strong>Name:</strong> ${body.firstName}</li>
-          <li><strong>Email:</strong> ${body.email}</li>
-          ${sourceRows}
-        </ul>
-        <p>You can reach out to welcome them or verify their subscription status.</p>`
-      );
-    } catch (notifyError) {
-      console.error('Failed to send admin registration email:', notifyError);
-    }
+    const sourceNote = sourceInfo?.designCaption || sourceInfo?.designUrl || '';
+
+    await sendEmail({
+      to: body.email,
+      subject: 'Verify your email for Cross Stitch Pattern',
+      body: `
+        <p>Hello ${body.firstName},</p>
+        <p>Thanks for registering at Cross Stitch Pattern. Please verify your email to complete your registration:</p>
+        <p><a href="${verificationLink}">${verificationLink}</a></p>
+        <p>If you did not request this, you can ignore this email.</p>
+        ${sourceNote ? `<p>Requested from: ${sourceNote}</p>` : ''}
+      `,
+      html: true,
+    });
 
     return NextResponse.json(
-      { ok: true, userId: result.userId },
+      { ok: true, message: 'Please check your email to verify your address.' },
       { status: 200 },
     );
   } catch (error) {
diff --git a/src/app/api/register-only/verify/route.ts b/src/app/api/register-only/verify/route.ts
new file mode 100644
index 0000000..d2bd363
--- /dev/null
+++ b/src/app/api/register-only/verify/route.ts
@@ -0,0 +1,65 @@
+import { NextResponse } from 'next/server';
+import { verifyUserByToken } from '@/lib/users';
+import { sendEmailToAdmin } from '@/lib/email-service';
+
+export async function GET(req: Request): Promise<Response> {
+  try {
+    const url = new URL(req.url);
+    const token = url.searchParams.get('token') || '';
+
+    if (!token) {
+      return NextResponse.json(
+        { error: 'Missing verification token' },
+        { status: 400 },
+      );
+    }
+
+    const redirectParam = url.searchParams.get('redirect');
+    const result = await verifyUserByToken(token);
+    if (!result) {
+      return NextResponse.json(
+        { error: 'Invalid or expired token' },
+        { status: 400 },
+      );
+    }
+
+    try {
+      await sendEmailToAdmin(
+        'User email verified',
+        `<p>User verified their email.</p>
+         <ul>
+           <li><strong>Email:</strong> ${result.email ?? 'unknown'}</li>
+           <li><strong>Name:</strong> ${result.firstName ?? 'unknown'}</li>
+         </ul>`,
+      );
+    } catch (notifyError) {
+      console.error('Failed to send admin verification notification:', notifyError);
+    }
+
+    const host = req.headers.get('host') || 'cross-stitch-pattern.net';
+    const protocol =
+      host.includes('localhost') || host.startsWith('127.')
+        ? 'http'
+        : req.headers.get('x-forwarded-proto') || 'https';
+    const baseUrl = `${protocol}://${host}`;
+
+    if (result.cid) {
+      let targetUrl: URL;
+      try {
+        targetUrl = redirectParam
+          ? new URL(redirectParam, baseUrl)
+          : new URL(`${baseUrl}/`);
+      } catch {
+        targetUrl = new URL(`${baseUrl}/`);
+      }
+      targetUrl.searchParams.set('cid', result.cid);
+      targetUrl.searchParams.set('eid', 'verified');
+      return NextResponse.redirect(targetUrl.toString(), { status: 302 });
+    }
+
+    return NextResponse.json({ ok: true, message: 'Email verified' }, { status: 200 });
+  } catch (error) {
+    const message = error instanceof Error ? error.message : 'Server error';
+    return NextResponse.json({ error: message }, { status: 500 });
+  }
+}
diff --git a/src/lib/data-access.ts b/src/lib/data-access.ts
index fc3172c..a0899fe 100644
--- a/src/lib/data-access.ts
+++ b/src/lib/data-access.ts
@@ -8,6 +8,7 @@ import {
   ScanCommandInput,
   UpdateItemCommand,
 } from "@aws-sdk/client-dynamodb";
+import { randomUUID } from "crypto";
 import type { Design, DesignsResponse } from '@/app/types/design';
 import type { Album, AlbumsResponse } from '@/app/types/album';
 
@@ -260,10 +261,12 @@ export async function getAlbumCaption(albumId: number): Promise<string | undefin
 export async function getAllAlbumCaptions(): Promise<{ albumId: number; Caption: string }[] | undefined> {
   return withCache(async () => {
     try {
-      const albums = Array.from(albumCache.values()).map(album => ({
-        albumId: album.AlbumID,
-        Caption: album.Caption,
-      }));
+      const albums = Array.from(albumCache.values())
+        .map(album => ({
+          albumId: album.AlbumID,
+          Caption: album.Caption,
+        }))
+        .sort((a, b) => a.Caption.localeCompare(b.Caption, undefined, { sensitivity: 'base' }));
 
       if (albums.length === 0) {
         console.warn(`No albums found in cache`);
@@ -692,6 +695,7 @@ export async function verifyUser(email: string, password: string): Promise<boole
 // Create a new user in DynamoDB
 export async function createUser(email: string, password: string, username: string, subscriptionId: string, receiveUpdates: boolean): Promise<void> {
   const userId = `USR#${email}`;
+  const cid = randomUUID();
   try {
     console.log('Creating user:', { email, username, subscriptionId, receiveUpdates });
     const maxNPage = await getMaxUserNPage();
@@ -708,6 +712,7 @@ export async function createUser(email: string, password: string, username: stri
         ReceiveUpdates: { BOOL: receiveUpdates },
         DateCreated: { S: new Date().toISOString() },
         NPage: { S: newNPage },
+        cid: { S: cid },
         EntityType: { S: "USER" },
       },
       ConditionExpression: 'attribute_not_exists(ID)', // Prevent overwrites
@@ -727,6 +732,7 @@ export async function createUser(email: string, password: string, username: stri
 // Create a new test user in DynamoDB
 export async function createTestUser(email: string, password: string, username: string, subscriptionId: string, receiveUpdates: boolean): Promise<void> {
   const userId = `TST#${email}` + Date.now();
+  const cid = randomUUID();
   try {
     console.log('Creating test user:', { email, username, subscriptionId, receiveUpdates });
     const putParams = {
@@ -740,6 +746,7 @@ export async function createTestUser(email: string, password: string, username:
         ReceiveUpdates: { BOOL: receiveUpdates },
         DateCreated: { S: new Date().toISOString() },
         NPage: { S: "00000" },
+        cid: { S: cid },
         EntityType: { S: "USER" },
       },
       ConditionExpression: 'attribute_not_exists(ID)', // Prevent overwrites
@@ -756,6 +763,58 @@ export async function createTestUser(email: string, password: string, username:
   }
 }
 
+/**
+ * Update LastEmailEntry for a user (primary table) identified by cid.
+ * Uses a scan (no index on cid) and updates the first matching record.
+ */
+export async function updateLastEmailEntryByCid(cid: string): Promise<void> {
+  const tableName = process.env.DYNAMODB_TABLE_NAME;
+  if (!tableName) {
+    console.warn('DYNAMODB_TABLE_NAME not set; skipping LastEmailEntry update');
+    return;
+  }
+
+  console.log(`Updating LastEmailEntry for user with cid: ${cid}`);
+  const trimmedCid = cid.trim();
+  if (!trimmedCid) {
+    console.warn('Empty cid provided; skipping LastEmailEntry update');
+    return;
+  }
+
+  const scanParams: ScanCommandInput = {
+    TableName: tableName,
+    FilterExpression: '#entityType = :user AND #cid = :cid',
+     ExpressionAttributeNames: {
+      '#entityType': 'EntityType',
+      '#cid': 'cid',
+    },
+    ExpressionAttributeValues: {
+      ':user': { S: 'USER' },
+      ':cid': { S: trimmedCid },
+    },
+    ProjectionExpression: 'ID'
+  };
+
+  const { Items } = await dynamoDBClient.send(new ScanCommand(scanParams));
+  const id = Items?.[0]?.ID?.S;
+  if (!id) {
+    console.warn(`No user found for cid ${trimmedCid} in ${tableName}, id: ${id}`);
+    return;
+  }
+
+  const nowIso = new Date().toISOString();
+
+  await dynamoDBClient.send(
+    new UpdateItemCommand({
+      TableName: tableName,
+      Key: { ID: { S: id } },
+      UpdateExpression: 'SET #lastEmailEntry = :now',
+      ExpressionAttributeNames: { '#lastEmailEntry': 'LastEmailEntry' },
+      ExpressionAttributeValues: { ':now': { S: nowIso } },
+    }),
+  );
+}
+
 export async function refreshCache(): Promise<void> {
   console.info('Refreshing cache');
   designCache.clear();
diff --git a/src/lib/error-logger.ts b/src/lib/error-logger.ts
new file mode 100644
index 0000000..b9d71f8
--- /dev/null
+++ b/src/lib/error-logger.ts
@@ -0,0 +1,18 @@
+// src/lib/errorLogger.ts
+
+function getLastUrl(): string {
+  const g = globalThis as typeof globalThis & {
+    __LAST_REQUEST_URL__?: string;
+  };
+  return g.__LAST_REQUEST_URL__ ?? 'Unknown URL';
+}
+
+process.on('unhandledRejection', (reason: unknown) => {
+  console.error('❌ [UNHANDLED_REJECTION]', reason);
+  console.error('➡️  [REQUEST THAT FAILED]', getLastUrl());
+});
+
+process.on('uncaughtException', (err: unknown) => {
+  console.error('❌ [UNCAUGHT_EXCEPTION]', err);
+  console.error('➡️  [REQUEST THAT FAILED]', getLastUrl());
+});
diff --git a/src/lib/global-error-handler.ts b/src/lib/global-error-handler.ts
new file mode 100644
index 0000000..920b920
--- /dev/null
+++ b/src/lib/global-error-handler.ts
@@ -0,0 +1,75 @@
+// Global error handler to log uncaught exceptions and unhandled rejections in one place.
+import { sendEmailToAdmin } from './email-service';
+
+const flag = Symbol.for('cross-stitch.globalErrorHandlerInitialized');
+const globalSymbols = globalThis as Record<string | symbol, unknown>;
+
+if (typeof window === 'undefined' && typeof process !== 'undefined' && !globalSymbols[flag]) {
+  // Optionally enable source map support when dependency is present (avoids build-time resolution errors).
+  let sourceMapsEnabled = false;
+  try {
+    const req = eval('require') as NodeRequire;
+    req('source-map-support/register');
+    sourceMapsEnabled = true;
+  } catch {
+    // Optional dependency not installed; continue without source maps.
+  }
+
+  const logError = (label: string, payload: Record<string, unknown>) => {
+    const entry = {
+      label,
+      timestamp: new Date().toISOString(),
+      sourceMapsEnabled,
+      runtime: process.release?.name,
+      nodeVersion: process.version,
+      ...payload,
+    };
+    console.error(JSON.stringify(entry, null, 2));
+  };
+
+  // Simple throttle to avoid email storms (1 minute minimum between notifications)
+  let lastEmailSentAt = 0;
+  const MIN_EMAIL_INTERVAL_MS = 60_000;
+
+  const notifyAdmin = async (label: string, payload: Record<string, unknown>) => {
+    const now = Date.now();
+    if (now - lastEmailSentAt < MIN_EMAIL_INTERVAL_MS) return;
+    lastEmailSentAt = now;
+
+    try {
+      const pretty = JSON.stringify(payload, null, 2);
+      await sendEmailToAdmin(
+        `[Error] ${label}`,
+        `<pre>${pretty}</pre>`,
+        true,
+      );
+    } catch (err) {
+      // If email fails, just log it; avoid throwing from handler
+      console.error('Failed to notify admin about error:', err);
+    }
+  };
+
+  process.on('uncaughtException', (err: Error) => {
+    const payload = {
+      name: err.name,
+      message: err.message,
+      stack: err.stack,
+    };
+    logError('uncaughtException', payload);
+    void notifyAdmin('uncaughtException', payload);
+  });
+
+  process.on('unhandledRejection', (reason: unknown) => {
+    const error = reason instanceof Error ? reason : null;
+    const payload = {
+      message: error ? error.message : String(reason),
+      name: error ? error.name : undefined,
+      stack: error ? error.stack : undefined,
+      type: error ? 'Error' : typeof reason,
+    };
+    logError('unhandledRejection', payload);
+    void notifyAdmin('unhandledRejection', payload);
+  });
+
+  globalSymbols[flag] = true;
+}
diff --git a/src/lib/users.ts b/src/lib/users.ts
index 1ea3296..3f7a076 100644
--- a/src/lib/users.ts
+++ b/src/lib/users.ts
@@ -20,6 +20,8 @@ export interface NewUserRegistration {
   email: string;
   firstName: string;
   password: string;
+  verificationToken?: string;
+  verificationTokenExpiresAt?: string;
 }
 
 /** Error thrown when email already exists in the users table */
@@ -50,6 +52,11 @@ export async function saveUserToDynamoDB(
   const firstName = input.firstName.trim();
   const password = input.password;
   const unsubscribeToken = randomUUID();
+  const cid = randomUUID();
+  const verificationToken = input.verificationToken || randomUUID();
+  const verificationTokenExpiresAt =
+    input.verificationTokenExpiresAt ||
+    new Date(Date.now() + 1000 * 60 * 60 * 48).toISOString(); // 48h default
 
   if (!email || !firstName || !password) {
     throw new Error('Missing required fields');
@@ -66,6 +73,11 @@ export async function saveUserToDynamoDB(
     CreatedAt: { S: createdAt },
     UnsubscribeToken: { S: unsubscribeToken },
     Unsubscribed: { BOOL: false },
+    cid: { S: cid },
+    VerificationToken: { S: verificationToken },
+    VerificationTokenExpiresAt: { S: verificationTokenExpiresAt },
+    Verified: { BOOL: false },
+    VerifiedAt: { S: '' },
   };
 
   const params: PutItemCommandInput = {
@@ -98,6 +110,209 @@ export type UnsubscribeResult =
   | { status: 'already-unsubscribed'; email?: string }
   | { status: 'not-found' };
 
+/**
+ * Fetch a verified user by cid (secondary users table).
+ */
+export async function getVerifiedUserByCid(
+  cid: string,
+): Promise<{ id: string; email?: string } | null> {
+  const tableName = process.env.DDB_USERS_TABLE;
+  if (!tableName) {
+    console.warn('DDB_USERS_TABLE not set; cannot fetch verified user by cid');
+    return null;
+  }
+
+  const trimmedCid = cid.trim();
+  if (!trimmedCid) return null;
+
+  const scanParams: ScanCommandInput = {
+    TableName: tableName,
+    FilterExpression: '#cid = :cid',
+    ExpressionAttributeNames: { '#cid': 'cid' },
+    ExpressionAttributeValues: { ':cid': { S: trimmedCid } },
+    ProjectionExpression: 'ID, Email, Verified, VerifiedAt',
+  };
+
+  let lastEvaluatedKey: Record<string, AttributeValue> | undefined;
+  let match: { id: string; email?: string; verified?: boolean; verifiedAt?: string } | null =
+    null;
+
+  do {
+    const { Items, LastEvaluatedKey } = await client.send(
+      new ScanCommand({ ...scanParams, ExclusiveStartKey: lastEvaluatedKey }),
+    );
+    const found = Items?.find((item) => item?.ID?.S);
+    if (found?.ID?.S) {
+      match = {
+        id: found.ID.S,
+        email: found.Email?.S,
+        verified: found.Verified?.BOOL,
+        verifiedAt: found.VerifiedAt?.S,
+      };
+      break;
+    }
+    lastEvaluatedKey = LastEvaluatedKey;
+  } while (lastEvaluatedKey);
+
+  if (!match) return null;
+  if (match.verified || (match.verifiedAt && match.verifiedAt.length > 0)) {
+    return { id: match.id, email: match.email };
+  }
+  return null;
+}
+
+/**
+ * Mark user verified by verification token; returns basic info or null if not found/expired.
+ */
+export async function verifyUserByToken(
+  token: string,
+): Promise<{ email?: string; firstName?: string; cid?: string } | null> {
+  const tableName = process.env.DDB_USERS_TABLE;
+  if (!tableName) {
+    console.warn('DDB_USERS_TABLE not set; cannot verify user');
+    return null;
+  }
+
+  const trimmedToken = token.trim();
+  if (!trimmedToken) {
+    return null;
+  }
+
+  const scanParams: ScanCommandInput = {
+    TableName: tableName,
+    FilterExpression: '#token = :token',
+    ExpressionAttributeNames: { '#token': 'VerificationToken' },
+    ExpressionAttributeValues: { ':token': { S: trimmedToken } },
+    ProjectionExpression:
+      'ID, Email, FirstName, VerificationTokenExpiresAt, Verified, cid',
+  };
+
+  let lastEvaluatedKey: Record<string, AttributeValue> | undefined;
+  let match:
+    | {
+        id: string;
+        email?: string;
+        firstName?: string;
+        expiresAt?: string;
+        verified?: boolean;
+        cid?: string;
+      }
+    | undefined;
+
+  do {
+    const { Items, LastEvaluatedKey } = await client.send(
+      new ScanCommand({ ...scanParams, ExclusiveStartKey: lastEvaluatedKey }),
+    );
+    const found = Items?.find((item) => item?.ID?.S);
+    if (found?.ID?.S) {
+      match = {
+        id: found.ID.S,
+        email: found.Email?.S,
+        firstName: found.FirstName?.S,
+        expiresAt: found.VerificationTokenExpiresAt?.S,
+        verified: found.Verified?.BOOL,
+        cid: found.cid?.S,
+      };
+      break;
+    }
+    lastEvaluatedKey = LastEvaluatedKey;
+  } while (lastEvaluatedKey);
+
+  if (!match) return null;
+
+  if (match.verified) {
+    return { email: match.email, firstName: match.firstName, cid: match.cid };
+  }
+
+  if (match.expiresAt && new Date(match.expiresAt).getTime() < Date.now()) {
+    console.warn('Verification token expired for user', match.id);
+    return null;
+  }
+
+  const nowIso = new Date().toISOString();
+
+  await client.send(
+    new UpdateItemCommand({
+      TableName: tableName,
+      Key: { ID: { S: match.id } },
+      UpdateExpression:
+        'SET #verified = :true, #verifiedAt = :now REMOVE #token, #tokenExp',
+      ExpressionAttributeNames: {
+        '#verified': 'Verified',
+        '#verifiedAt': 'VerifiedAt',
+        '#token': 'VerificationToken',
+        '#tokenExp': 'VerificationTokenExpiresAt',
+      },
+      ExpressionAttributeValues: {
+        ':true': { BOOL: true },
+        ':now': { S: nowIso },
+      },
+    }),
+  );
+
+  return { email: match.email, firstName: match.firstName, cid: match.cid };
+}
+
+/**
+ * Update LastEmailEntry for a user in the secondary users table by cid.
+ * Uses a scan (no index on cid) and updates the first matching record.
+ */
+export async function updateLastEmailEntryInUsersTable(
+  cid: string,
+): Promise<void> {
+  const tableName = process.env.DDB_USERS_TABLE;
+  if (!tableName) {
+    console.warn('DDB_USERS_TABLE not set; skipping LastEmailEntry update');
+    return;
+  }
+
+  const trimmedCid = cid.trim();
+  if (!trimmedCid) {
+    console.warn('Empty cid provided; skipping LastEmailEntry update');
+    return;
+  } 
+   
+  const scanParams: ScanCommandInput = {
+    TableName: tableName,
+    FilterExpression: '#cid = :cid',
+    ExpressionAttributeNames: { '#cid': 'cid' },
+    ExpressionAttributeValues: { ':cid': { S: trimmedCid } },
+    ProjectionExpression: 'ID',
+  };
+
+  let lastEvaluatedKey: Record<string, AttributeValue> | undefined;
+  let id: string | undefined;
+
+  do {
+    const { Items, LastEvaluatedKey } = await client.send(
+      new ScanCommand({ ...scanParams, ExclusiveStartKey: lastEvaluatedKey }),
+    );
+    const match = Items?.find((item) => item?.ID?.S);
+    if (match?.ID?.S) {
+      id = match.ID.S;
+      break;
+    }
+    lastEvaluatedKey = LastEvaluatedKey;
+  } while (lastEvaluatedKey);
+
+  if (!id) {
+    console.warn(`No user found for cid ${trimmedCid} in ${tableName}`);
+    return;
+  }
+
+  const nowIso = new Date().toISOString();
+
+  await client.send(
+    new UpdateItemCommand({
+      TableName: tableName,
+      Key: { ID: { S: id } },
+      UpdateExpression: 'SET #lastEmailEntry = :now',
+      ExpressionAttributeNames: { '#lastEmailEntry': 'LastEmailEntry' },
+      ExpressionAttributeValues: { ':now': { S: nowIso } },
+    }),
+  );
+}
+
 /**
  * Marks a user as unsubscribed based on their unique unsubscribe token.
  * Scans CrossStitchUsers for the token, then flips Unsubscribed to true.
diff --git a/src/middleware.ts b/src/middleware.ts
new file mode 100644
index 0000000..2ca58e6
--- /dev/null
+++ b/src/middleware.ts
@@ -0,0 +1,19 @@
+// src/middleware.ts
+import { NextRequest, NextResponse } from 'next/server';
+
+export function middleware(request: NextRequest) {
+  const g = globalThis as typeof globalThis & {
+    __LAST_REQUEST_URL__?: string;
+  };
+
+  g.__LAST_REQUEST_URL__ =
+    `${request.method} ${request.nextUrl.pathname}${request.nextUrl.search}`;
+
+  return NextResponse.next();
+}
+
+export const config = {
+  matcher: [
+    '/((?!_next/static|_next/image|favicon.ico|robots.txt|sitemap.xml).*)',
+  ],
+};
